---
title: "Goの循環的複雑度と認知的複雑度を計測してコードをシンプルに保つ"
emoji: "🦔"
type: "tech"
topics: ["go"]
published: true
published_at: 2025-12-21 09:00
publication_name: "kaonavi"
---

この記事は[株式会社カオナビ Advent Calendar 2025](https://qiita.com/advent-calendar/2025/kaonavi) シーズン3の21日目です。

---

コードの複雑さを計測する指標として循環的複雑度（Cyclomatic Complexity）と認知的複雑度（Cognitive Complexity）があります。
この指標を使うことで、保守しづらい・理解しづらいコードを定量的に把握し、リファクタリングが必要な箇所を判断できるようになります。

Go言語で開発する場合は以下のlinterを使用することでこれらの指標を計測することができます。
（golangci-lintにも組み込まれています）

- 循環的複雑度: [gocyclo](https://github.com/fzipp/gocyclo)
- 認知的複雑度: [gocognit](https://github.com/uudashr/gocognit)

## 循環的複雑度(Cyclomatic Complexity)

関数やメソッドの構造的複雑さを表す指標です。
値が高いほどコードの修正・リファクタリング時のリスクが高いことがわかります。

循環的複雑度は以下の処理を使用すると複雑度がカウントされます。

- for
- if, else if
- switchの各case文
- 論理演算子(&&, ||) の使用（1つの論理演算子ごとに+1）

以下のようにif文を記述した場合に複雑度が +1 されます。

```go
if 条件1 { // cyclomatic +1
    // do something
}
```

循環的複雑度は分岐点の数に応じて数が増えるため、以下のようにif文がネストしていてもそれぞれのif文に対して +1 された値が算出されます。

```go
if 条件1 { // cyclomatic +1
    if 条件2 { // cyclomatic +1
        if 条件3 { // cyclomatic +1
            // do something
        }
    }
}
```

循環的複雑度のしきい値は一般的には以下のようになっているようです。

- 1 ~ 10: シンプルなモジュール
- 11 ~ 20: 中程度のリスクを伴う複雑なモジュール
- 21 ~ 50: リスクの高い複雑なモジュール
- 50 ~ : 非常に高いリスクを伴うテスト不可能なモジュール

### コード例

※複雑度が高いだけのコードで中身に特に意味はないです

#### 循環的複雑度5のコード

```go
func Cyclomatic5(status string, code int) string {
	if status == "active" {
		if code > 0 {
			return "running"
		} else {
			return "idle"
		}
	} else {
		if code < 0 {
			return "error"
		} else if code > 100 {
			return "overload"
		}
	}
	return "unknown"
}
```

#### 循環的複雑度10のコード

10くらいであればまだ十分読めるレベルです。

```go
func Cyclomatic10(input string, level int) bool {
	if input == "" {
		return false
	}

	if len(input) < 3 {
		return false
	}

	if len(input) > 100 {
		return false
	}

	if level > 0 {
		if level < 5 {
			if input[0] >= 'A' && input[0] <= 'Z' {
				return true
			}
		} else {
			if input[0] >= 'a' && input[0] <= 'z' {
				return true
			}
		}
	} else {
		return false
	}

	return false
}
```

#### 循環的複雑度15のコード

このくらいになるとかなりコードを読むのが難しくなります。
複雑度15がこのようなコードなので、20や50を超えるような実装は相当複雑な実装であることが想像できるかと思います。

```go
func Cyclomatic15(points int, bonus int, multiplier float64) int {
	score := 0

	if points > 0 {
		score = points

		if bonus > 0 {
			if bonus > 10 {
				score += bonus * 2

				if bonus > 20 {
					score += 5
				}
			} else {
				score += bonus

				if bonus > 5 {
					score += 2
				}
			}
		}

		if multiplier > 1.0 {
			if multiplier > 2.0 {
				score = int(float64(score) * 2.0)

				if multiplier > 3.0 {
					score += 10
				}
			} else {
				score = int(float64(score) * multiplier)
			}
		}

		if score > 100 {
			if score > 200 {
				score = 200
			} else {
				if score > 150 {
					score -= 10

					if score > 170 {
						score -= 5
					}
				}
			}
		} else {
			if score < 50 {
				score += 5

				if score < 30 {
					score += 3
				}
			}
		}
	} else {
		score = 0
	}

	return score
}
```

## 認知的複雑度(Cognitive Complexity)

コードの制御フローを理解するのがどれほど難しいかを示す指標です。
値が高いほどコードの理解が難しくなることを表しています。

認知的複雑度は以下の処理を使用すると複雑度がカウントされます。

- if, else if, else
- switch, select
- for
- goto LABEL, break LABEL, continue LABEL
- 論理演算子
  - 異なる論理演算子を使用するとカウントされ、連続する同じ論理演算子は対象外
    - `if 条件1 {}` は複雑度+1
	- `if 条件1 && 条件2 {}` は複雑度が+2
	- `if 条件1 && 条件2 && 条件3 {}` は複雑度が+2（同一演算子の連続）
	- `if 条件1 && 条件2 || 条件3 {}` は複雑度が+3（異なる演算子の使用）
- 再帰呼び出し

更にこれらがネストの深さに応じて複雑度の値が大きくなっていきます。

例えば、以下のような単一のif文では複雑度は +1 となりますが、

```go
if 条件 { // cognitive +1
    // do something
}
```

以下のようにif文がネストした場合、複雑度は子のif文に対して +2、更に孫に対して +3 されます。

```go
if 条件1 { // cognitive +1
    if 条件2 { // cognitive +2
        if 条件3 { // cognitive +3
            // do something
        }
    }
}
```

### コード例

#### 認知的複雑度5のコード

```go
func Cognitive5(orderType string, amount int) string {
	if orderType == "premium" { // +1
		if amount > 1000 { // +2 (ネスト深度1)
			return "premium-bulk"
		}
		return "premium-standard"
	}

	if amount > 500 { // +1
		return "bulk-order"
	}

	if amount > 100 { // +1
		return "standard-order"
	}

	return "small-order"
}
```

#### 認知的複雑度10のコード

```go
func Cognitive10(username string, age int, isPremium bool) bool {
	if username == "" { // +1
		return false
	}

	if len(username) < 3 { // +1
		if !isPremium { // +2 (ネスト深度1)
			return false
		}
	}

	if age < 18 { // +1
		if age < 13 { // +2 (ネスト深度1)
			return false
		}
		if !isPremium { // +2 (ネスト深度1)
			return false
		}
	}

	if isPremium { // +1
		return true
	}

	return age >= 18
}
```

#### 認知的複雑度15のコード

```go
func Cognitive15(weight int, distance int, isExpress bool, destination string) int {
	cost := 0

	if weight > 0 { // +1
		if weight > 10 { // +2 (ネスト深度1)
			cost = weight * 5

			if weight > 50 { // +3 (ネスト深度2)
				cost = cost * 2
			}
		} else { // +1
			cost = weight * 10
		}

		if distance > 100 { // +2 (ネスト深度1)
			if destination == "remote" { // +3 (ネスト深度2)
				cost += 200
			}
		}
	}

	if isExpress { // +1
		if cost > 100 { // +2 (ネスト深度1)
			cost += 100
		}
	}

	return cost
}
```

## golangci-lint での設定

golangci-lintには `gocyclo`, `gocognit` というlinterが入っています。
これらを有効化することで循環的複雑度、認知的複雑度のチェックを入れることができます。

- 循環的複雑度: [gocyclo](https://github.com/fzipp/gocyclo)
- 認知的複雑度: [gocognit](https://github.com/uudashr/gocognit)

これらのデフォルトのしきい値は 30 となっています。
デフォルトで使用した場合はしきい値はかなり高い値です。

golangci-lintの設定でも 10 ~ 20 が推奨されているため、以下のように設定を変更して使用すると良さそうです。
https://golangci-lint.run/docs/linters/configuration/


```yaml
linters:
  settings:
    # 循環的複雑度
    gocyclo:
      # Minimal code complexity to report.
      # Default: 30 (but we recommend 10-20)
      min-complexity: 10

    # 認知的複雑度
    gocognit:
      # Minimal code complexity to report.
      # Default: 30 (but we recommend 10-20)
      min-complexity: 10
```

## まとめ

循環的複雑度、認知的複雑度という2つの指標について書きました。

**循環的複雑度**: テストケースの必要数や、コード内の独立したパスの数を表します。
**認知的複雑度**: 人間がコードを読んで理解する際の難しさを表します。

複雑度の計測を早期に導入し、CIで継続的にチェックすることで、保守しやすいコードを維持できます。

実装時には以下のようなポイントを意識することができます:

- Early returnをする
- 関数の役割を明確にし、適切な単位で分割を行う
- packageや関数の責務が大きすぎないかを常に考える

### 指標を組み合わせて使用する

「循環的複雑度が高いが認知的複雑度は低い」、あるいは「循環的複雑度が低いが認知的複雑度は高い」というコードは当然あります。

例えばサンプルコードで認知的複雑度が 15 のコードの循環的複雑度は 8 です。
このコードは循環的複雑度だけを見た場合はシンプルに見えてしまいます。

複数の指標を組み合わせることによって、コードをよりシンプルで理解しやすい状態に保つことができます。
